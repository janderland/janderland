---
title: Intro to Foundation DB via a Distributed Mutex
date: 2025-12-27
...

At work, I found myself in apparent need of synchronizing
access to a shared resources. The actors requesting access
were two distributed services. Being fond and familiar with
the "assembly language of databases", I knew I could
implement a distributed mutex on top of Foundation DB. 

Calling Foundation DB the "assembly language of databases"
(something I once read on [Hacker News][]) is an
exaggeration. Nonetheless, Foundation DB does provide a set
primitives which makes accessing distributed memory safe and
graceful.

[Hacker News]: https://news.ycombinator.com/item?id=40328552

Further investigation into the requirements revealed that
synchronization was not necessary. Regardless, I implemented
the [distributed mutex][] in Go for fun, and in this post
I'll use that implementation to outline the features of
Foundation DB.

[distributed mutex]: https://github.com/janderland/fdb-mutex

## Intro to Foundation DB

[Foundation DB][] is a key-value database. Keys are byte
strings (less than 10kB) pointing at values which are
slightly larger byte strings (less than 100kB). Foundation
DB is designed for highly concurrent workloads with many
clients and many simultaneous transactions. Transactions
must take less than 60s to complete and read-write less
than 10MB of data.

[Foundation DB]: https://apple.github.io/foundationdb/index.html

The [transactions][] follow an optimistic concurrency model.
No key-values are ever locked from access. Instead, if any
of the key-values read by the transaction are modified
before the transaction commits, then the transaction is
rolled back and retried. When this happens, we call it
a [transaction conflict][].

[transactions]: https://apple.github.io/foundationdb/architecture.html#transaction-processing)
[transaction conflict]: https://apple.github.io/foundationdb/developer-guide.html#how-foundationdb-detects-conflicts

These conflicts prevent inconsistent reads and allow
Foundation DB to guarantee [ACID][] properties. There's
a catch though: data [consistency][] (the 'C' in ACID) is
left up to the client. Foundation DB does not ensure data
obeys any schema or constraints. As you'll see later in this
post, if the client is written properly, data consistency
emerges from transaction conflicts.

[ACID]: https://en.wikipedia.org/wiki/ACID
[consistency]: https://en.wikipedia.org/wiki/Consistency_(database_systems)

Foundation DB sorts its key-values by the numeric value of
the key's byte string. Given a byte string prefix, adjacent
key-values can be efficiently streamed to the client.
A group of key-values containing a common prefix is called
a [subspace][]. To add a new key-value to a subspace, you
simply write a key-value with the appropriate prefix, and
due to sorting, the key-value will be placed beside its
peers.

[subspace]: https://apple.github.io/foundationdb/developer-guide.html#subspaces

Foundation DB provides a special kind of subspace called
a [directory][]. Traditional directory paths are mapped to
short byte string prefixes. For instance, the path
`/my/dir/path` could be mapped to the prefix `0xfa3209`.
Key-values written into this directory would include this
prefix.

[directory]: https://apple.github.io/foundationdb/developer-guide.html#directories

Foundation DB provides an encoding scheme for [tuples][].
This allows clients to encode common data types (integer,
float, boolean, string) with [deterministic ordering][]. For
instance, when used as a key, the tuple `(23,"abc")` will
always appear before the tuple `(52,"xyz")`.

[tuples]: https://apple.github.io/foundationdb/data-modeling.html#tuples
[deterministic ordering]: https://github.com/apple/foundationdb/blob/main/design/tuple.md

When a transaction is committed, it receives a unique
12-byte ID called a [versionstamp][]. The first 10 bytes are
a monotonically increasing integer and the last 2 bytes are
chosen by the client of the transaction. The integer is
incremented around once per nanosecond. For a given
database, you'll never observe the same versionstamp twice,
so they can be used as unique IDs or as a noncontinuous
sequence.

[versionstamp]: https://apple.github.io/foundationdb/data-modeling.html#versionstamps
[not exact]: https://forums.foundationdb.org/t/versionstamp-as-absolute-time/2442/2?u=janderland

## Key-Value Schema

The schema for our mutex is simple. We will have a key-value
for identifying the owner of the mutex and a [queue][] on
which waiting clients may place themselves. When the owner
of the mutex releases, it will grab the next client from the
head of the queue and make them the owner. Clients can watch
the key-value specifying the owner and unblock when they are
given control of the mutex.

[queue]: https://apple.github.io/foundationdb/data-modeling.html#arrays

Because this is a distributed system, there is always the
chance that the owner of the mutex could die and deadlock
the entire application. To avoid this, the owner will be
required to heartbeat the mutex. A background service will
watch for stale heartbeats and pass the mutex ownership on
to the next client.

Using my [query language][], we can define the schema as
follows:

[query language]: https://github.com/janderland/fql

```
% Always one owner key.
/path/to/mutex("owner",<name:str>)=<heartbeat:vstamp>

% Zero or more queue keys.
/path/to/mutex("queue",<index:vstamp>)=<name:str>
```

The `name` strings are unique identifiers provided by the
clients. Heartbeats and indexes (for ordering the queue) are
written using versionstamps. As long as the heartbeat value
keeps changing, we know the mutex owner is still alive.
Because versionstamps are monotonically increasing, new
clients will always be placed at the back of the queue.

We can easily dump the total state of the mutex by reading
its entire subspace:

``` {.query}
% Read the entire mutex state.
/path/to/mutex(...)
```

``` {.result}
/path/to/mutex("owner","roger")=0x52750b30ffbc7de3b3620000
/path/to/mutex("queue",0x52750b30ffbbdbb3348f0000)="daniel"
/path/to/mutex("queue",0x52750b30ffbb3982b5bc0000)="leo"
/path/to/mutex("queue",0x52750b30ffba975236e90000)="wilma"
```

> This article uses features of FQL (my [query language][])
> which I have yet to document publicly. I'm hoping the
> language is simple enough that readers can infer what the
> queries mean.

## Implementing the Schema

As state earlier, Foundation DB does nothing to enforce the
above schema; it's up to the client to ensure the data is
properly structured. For this reason, Foundation DB is never
exposed to the open web. Only "safe", authorized clients are
expected to interact with the DB directly.

In the client implementation, I usually isolate the
marshaling of key-values to help make the schema explicit.
Below, I'll list the prototypes of the [marshaling
methods][]:

[marshaling methods]: https://github.com/janderland/fdb-mutex/blob/5075a63324ef2c49d517b714134bff003a45093a/kv.go#L183

```language-go
func (x *Mut) packOwnerRange() (fdb.KeyRange, error)
func (x *Mut) packOwnerKey(name string) fdb.Key
func (x *Mut) unpackOwnerKey(key fdb.Key) (string, error)
func (x *Mut) packOwnerValue() []byte
func (x *Mut) packQueueRange() (fdb.KeyRange, error)
func (x *Mut) packQueueKey() (fdb.Key, error)
func (x *Mut) packQueueValue(name string) []byte
func (x *Mut) unpackQueueValue(val []byte) string
```

Using these marshaling methods, I implement a [method for
each query][]. The queries accept an `fdb.Transactor` as an
argument. This can be either the handle to the database, or
a running transaction, allowing the queries to be run in
isolation, or composed together into a single transaction.

[method for each query]: https://github.com/janderland/fdb-mutex/blob/5075a63324ef2c49d517b714134bff003a45093a/kv.go#L23

```language-go
func (x *Mut) setOwner(db fdb.Transactor, name string) error 
func (x *Mut) getOwner(db fdb.Transactor) (owner, error) 
func (x *Mut) watchOwner(ctx context.Context, db fdb.Transactor) <-chan error 
func (x *Mut) heartbeat(db fdb.Transactor, name string) error 
func (x *Mut) enqueue(db fdb.Transactor, name string) error 
func (x *Mut) dequeue(db fdb.Transactor) (string, error) 
```

Finally, the public methods can string together several
queries to implement the desired behavior. Below is the
implementation for acquiring the mutex:

```language-go
// Blocks until the current client is the owner of the mutex. The `ctx`
// argument includes a cancelation token for aborting the operation.
func (x *Mut) Acquire(ctx context.Context, db fdb.Database) error {
  // Attempts a non-blocking aquire. If it succeeds, we can return.
  acquired, err := x.TryAcquire(db)
  if err != nil {
    return fmt.Errorf("failed to try aquire: %w", err)
  }
  if acquired {
    return nil
  }

  // Check if we're the mutex owner. If not, then watch for writes on
  // the owner key-value. When the watch fires, check if we're the owner
  // again. Loop forever until either we are the owner or the cancelation
  // token fires.
  for {
    watch, err := db.Transact(func(tr fdb.Transaction) (any, error) {
      owner, err := x.getOwner(tr)
      if err != nil {
        return nil, fmt.Errorf("failed to get owner: %w", err)
      }

      // Return a nil watch to signal that
      // we are now the owner of the mutex.
      if owner.name == x.name {
        return nil, nil
      }

      return x.watchOwner(ctx, tr), nil
    })
    if err != nil {
      return err
    }

    // If watch is nil then we are the owner.
    // Otherwise, wait for the watch to fire
    // and check again.
    if watch == nil {
      return nil
    }
    if err := <-watch.(<-chan error); err != nil {
      return fmt.Errorf("failed to watch owner: %w", err)
    }
  }
}
```

## Ensuring Consistency

## Integration Testing

## Conclusion
