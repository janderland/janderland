---
title: Intro to Foundation DB via a Distributed Mutex
date: 2025-12-27
...

At work, I found myself in apparent need of synchronizing
access to a shared resources. The actors requesting access
were two distributed services. Being fond and familiar with
the "assembly language of databases", I knew I could
implement a distributed mutex on top of Foundation DB. 

Calling Foundation DB the "assembly language of databases"
(something I once read on [Hacker News][]) is an
exaggeration. Nonetheless, Foundation DB does provide a set
primitives which makes accessing distributed memory safe and
graceful.

[Hacker News]: https://news.ycombinator.com/item?id=40328552

Further investigation into the requirements revealed that
synchronization was not necessary. Regardless, I implemented
the [distributed mutex][] in Go for fun, and in this post
I'll use that implementation to outline the features of
Foundation DB.

[distributed mutex]: https://github.com/janderland/fdb-mutex

## Intro to Foundation DB

[Foundation DB][] is a key-value database. Keys are byte
strings (less than 10kB) pointing at values which are
slightly larger byte strings (less than 100kB). Foundation
DB is designed for highly concurrent workloads with many
clients and many simultaneous transactions. Transactions
must take less than 60s to complete and read or write less
than 10MB of combined data.

[Foundation DB]: https://apple.github.io/foundationdb/index.html

The [transactions][] follow an optimistic concurrency model.
No key-values are ever locked from access. Instead, if any
of the key-values read by the transaction are modified
before the transaction commits, then the transaction is
rolled back and retried. When this happens, we call it
a [transaction conflict][].

[transactions]: https://apple.github.io/foundationdb/architecture.html#transaction-processing)
[transaction conflict]: https://apple.github.io/foundationdb/developer-guide.html#how-foundationdb-detects-conflicts

These conflicts prevent inconsistent reads and allow
Foundation DB to guarantee [ACID][] properties, granted the
data model's consistency is left up to the client.
Foundation DB does not ensure the data obeys any schema or
constraints. As you'll see later in this post, if the client
is written properly, data model consistency emerges from
transaction conflicts.

[ACID]: https://en.wikipedia.org/wiki/ACID

Foundation DB sorts it's key-values by the numeric value of
the byte string key. Given a byte string prefix, adjacent
key-values can be efficiently streamed to the client.
A group of key-values containing a common prefix is called
a [subspace][]. To add a new key-value to a subspace, you
simply write a key-value with the appropriate prefix, and
due to sorting, the key-value will be placed amongst it's
peers.

[subspace]: https://apple.github.io/foundationdb/developer-guide.html#subspaces

While the client is free to encode keys an it pleases,
Foundation DB provides an encoding scheme called the [tuple
layer][]. This allows clients to encode a tuple containing
common data types (int, float, bool, string) with
[deterministic ordering][]. For instance, the tuple
`(23,"abc")` will always appear before the tuple
`(52,"xyz")`.

[tuple layer]: https://apple.github.io/foundationdb/data-modeling.html#tuples
[deterministic ordering]: https://github.com/apple/foundationdb/blob/main/design/tuple.md

When a transaction is committed, it receives a unique
12-byte ID called a [versionstamp][]. The first 10 bytes are
a monotonically increasing integer and the last 2 bytes are
chosen by the client of the transaction. The integer is
incremented around once per nanosecond (though this is [not
exact][]) and therefore, subtracting two versionstamps from
one another renders a rough time duration. Because each
versionstamp is unique, it also can be used to represent
a unique ID. 

[versionstamp]: https://apple.github.io/foundationdb/data-modeling.html#versionstamps
[not exact]: https://forums.foundationdb.org/t/versionstamp-as-absolute-time/2442/2?u=janderland

## Mutex Schema

The schema for our mutex is simple. We will have a key-value
for identifying the owner of the mutex and a [queue][] on
which waiting clients may place themselves. When the owner
of the mutex releases, it will grab the next client from the
head of the queue and make them the owner. Clients can watch
the key-value specifying the owner and unblock when they are
given control of the mutex.

[queue]: https://apple.github.io/foundationdb/data-modeling.html#arrays

Because this is a distributed system, there is always the
chance that the owner of the mutex could die and deadlock
the entire application. To avoid this, the owner will be
required to heartbeat the mutex. A background service will
watch for stale heartbeats and pass the mutex ownership on
to the next client.

Using my partially completed [query language][], we can
define the schema as follows:

[query language]: https://github.com/janderland/fql

```
% Always one owner key.
/subspace("owner",<name:str>)=<heartbeat:vstamp>

% Zero or more queue keys.
/subspace("queue",<index:vstamp>)=<name:str>
```

The `name` strings are unique identifiers provided by the
clients. Heartbeats and indexes (for ordering the queue) are
written using versionstamps. As long as the heartbeat value
keeps changing, we'll know the mutex owner is still alive.
Because versionstamps are monotonically increasing, new
clients will always be placed at the back of the queue.

> This article will use features of FQL (the query language)
> which I have yet to document publicly. I'm hoping the
> language is simple enough that readers can infer what the
> queries mean.

## Isolate the Queries

## Watching the Owner

## Integration Testing

## Conclusion
